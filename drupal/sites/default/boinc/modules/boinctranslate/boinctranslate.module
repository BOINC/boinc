<?php
// $Id$

/**
 * @file
 * Provides common BOINC module functionality.
 *
 * In general, any custom feature or function required independently by
 * multiple BOINC modules should be in this module.
 */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
 * Includes that provide supporting functions
 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

//require_once('includes/boinctranslate.forms.inc');
//require_once('includes/boinctranslate.helpers.inc');
require_once('boinctranslate.admin.inc');


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
 * Hooks into core modules
 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 
/**
 * Implementation of hook_menu(); determine the actions that correspond
 * with defined URL paths
 */
function boinctranslate_menu() {
  $items['admin/boinc/translation'] = array(
    'title' => 'Environment: Translation',
    'description' => 'Configure URLs for translation files (i.e. integration
      with BOINC Translation Services).',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('boinctranslate_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'boinctranslate.admin.inc'
  );
  $items['admin/boinc/translation/export'] = array(
    'title' => 'Export translations',
    'page callback' => 'boinctranslate_export_translations',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/boinc/translation/import'] = array(
    'title' => 'Import translations',
    'page callback' => 'boinctranslate_refresh_translations',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/boinc/translation/initialize-languages'] = array(
    'title' => 'Install official BOINC languages',
    'page callback' => 'boinctranslate_initialize_languages',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/boinc/translation/update-official-boinc'] = array(
    'title' => 'Update official BOINC translations',
    'page callback' => 'boinctranslate_update_official_boinc_translations',
    'access arguments' => array('update official BOINC translations'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}


/**
 * Implementation of hook_panels_pane_content_alter()
 * This workaround makes panel page titles and pane titles translatable
 */
function boinctranslate_panels_pane_content_alter($content, $pane, $args, $context) {
  if ($content->title) {
    $content->title = t($content->title);
  }
  return $content;
}

/**
 * Implementation of hook_perm()
 */
function boinctranslate_perm() {
  return array('update official BOINC translations');
}

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
 * Page callbacks from hook_menu()
 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/**
 * 
 */
function boinctranslate_initialize_languages() {
  require_once(getcwd() . '/includes/locale.inc');
  $api_base_url = 'https://www.transifex.com/api/2';
  $project_name = variable_get(
    'boinc_translate_transifex_project_name', ''
  );
  $operations = array();
  
  if ($project_name) {
    // Get all languages configured for this project at Transifex
    $path = "project/{$project_name}/languages";
    $response = boinctranslate_transifex_request($path);
    
    if ($response == '404 NOT FOUND') {
      drupal_set_message(
        t('Unable to get languages for %project.',
          array(
            '%project' => $project_name,
          )
        ), 'warning'
      );
    }
    elseif ($response) {
      if (is_array($response)) {
      
        $installed_languages = language_list();
        $available_languages = _locale_get_predefined_list();
        $transifex_languages = array();
        $process_batches = FALSE;
        
        // Set up Transifex languages in Drupal
        foreach ($response as $language) {
          $posix_code = $language['language_code'];
          $rfc_code = strtolower(str_replace('_', '-', $posix_code));
          if (!isset($installed_languages[$rfc_code])) {
            // See if this language can be installed from a predefined list
            if (isset($available_languages[$rfc_code])) {
              locale_add_language(
                $rfc_code,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                FALSE
              );
              drupal_set_message(
                'Added predefined language: '.$available_languages[$rfc_code][0]
              );
            }
            else {
              // Retrieve language details from Transifex
              $path = "language/{$posix_code}";
              $response = boinctranslate_transifex_request($path);
              
              if ($response == '404 NOT FOUND') {
                drupal_set_message(
                  t('Unable to get details for language %code.',
                    array(
                      '%code' => $posix_code,
                    )
                  ), 'warning'
                );
              }
              elseif ($response) {
                if (!empty($response['name'])) {
                  // Add a custom language to Drupal (and set to disabled)
                  locale_add_language(
                    $rfc_code,
                    $response['name'],
                    $response['name'],
                    $response['rtl'],
                    NULL,
                    NULL,
                    FALSE
                  );
                  drupal_set_message(
                    'Added new language: '.$response['name']
                  );
                }
                else {
                  $variables = array(
                    '%code' => $posix_code,
                  );
                  drupal_set_message(
                    t('Unable to get details for language %code.', $variables),
                    'error'
                  );
                  watchdog(
                    'boinctranslate',
                    'Unable to get details for language %code.',
                    $variables,
                    WATCHDOG_ERROR
                  );
                }
              }
              else {
               $variables = array(
                  '%code' => $posix_code,
                );
                drupal_set_message(
                  t('Invalid response while getting details for language %code.', $variables),
                  'error'
                );
                watchdog(
                  'boinctranslate',
                  'Invalid response while getting details for language %code.',
                  $variables,
                  WATCHDOG_ERROR
                );
              }
            }
            // Import any language files for the newly added language
            if ($batch = locale_batch_by_language($rfc_code, '_locale_batch_language_finished')) {
              $operations = array_merge($operations, $batch['operations']);
              $process_batches = TRUE;
            }
          }
        }
        drupal_set_message('Finished installing official BOINC languages.');
        if ($process_batches) {
          $batch = array(
            'operations' => $operations,
          );
          drupal_set_message('Updating translations...<pre>' . print_r($batch,1) . '</pre>');
          batch_set($batch);
          batch_process('admin/boinc/translation');
        }
      }
      else {
        $variables = array(
          '%project' => $project,
        );
        drupal_set_message(
          t('No languages found for %project. (Does the configured account have sufficient privileges at Transifex?)', $variables),
          'error'
        );
        watchdog(
          'boinctranslate',
          'No languages found for %project. (Does the configured account have sufficient privileges at Transifex?)',
          $variables,
          WATCHDOG_ERROR
        );
      }
    }
    else {
     $variables = array(
        '%project' => $project,
      );
      drupal_set_message(
        t('Invalid response while getting languages for %project.', $variables),
        'error'
      );
      watchdog(
        'boinctranslate',
        'Invalid response while getting languages for %project.',
        $variables,
        WATCHDOG_ERROR
      );
    }
  }
  drupal_goto('admin/boinc/translation');
}

/**
 *
 */
function boinctranslate_export_translations() {
  require_once(getcwd() . '/includes/locale.inc');
  $project_name = variable_get(
    'boinc_translate_transifex_project_name', ''
  );
  
  if ($project_name) {
    // Create or update the translation source, if needed
    $source_exists = FALSE;
    $path = "project/{$project_name}/resources";
    $resources = boinctranslate_transifex_request($path);
    if ($resources AND is_array($resources)) {
      foreach ($resources as $resource) {
        if ($resource['slug'] == 'drupal-project') {
          $source_exists = TRUE;
          break;
        }
      }
      if (!$source_exists) {
        // Create the source
        $path = "project/{$project_name}/resources";
        $post = array(
          'slug' => 'drupal-project',
          'name' => 'Drupal-Project',
          'i18n_type' => 'PO',
          'category' => 'Drupal',
          'content' => boinctranslate_get_po('en', 'project'),
        );
      }
      else {
        // Update the source
        $path = "project/{$project_name}/resource/drupal-project/content";
        $post = array(
          'content' => boinctranslate_get_po('en', 'project')
        );
      }
      $result = boinctranslate_transifex_request($path, $post);
    }
    
    if (substr($result, 0, 6) != 'ERROR:') {
      $enabled_languages = locale_language_list();
      if ($source_exists) {
        drupal_set_message('Updated source translation strings at Transifex');
      }
      else {
        drupal_set_message('Established new translation resource at Transifex');
      }
      // Ensure this exported project resource is in the config
      $resource_config = (variable_get(
        'boinc_translate_transifex_project_resources', ''
      ));
      $resource_names = boinctranslate_parse_resources($resource_config);
      if (!in_array('drupal-project', $resource_names)) {
        $resource_config .= "\n" . 'drupal-project';
        variable_set(
          'boinc_translate_transifex_project_resources',
          $resource_config
        );
        drupal_set_message(
          'Added drupal-project to Project-specific resources'
        );
      }
      // Try to export translations for all enabled languages
      foreach ($enabled_languages as $langcode => $language_name) {
        if ($langcode == en) {
          continue;
        }
        $po_file = boinctranslate_get_po($langcode, 'project');
        if ($po_file) {
          $path = "project/{$project_name}/resource/drupal-project/translation/{$langcode}";
          $post = array(
            'content' => $po_file,
          );
          $result = boinctranslate_transifex_request($path, $post, TRUE, TRUE);
          if (!is_array($result)
          AND substr($result, 0, 6) == 'ERROR:') {
            drupal_set_message(
              "Unable to update {$language_name} translations: {$result}",
              'warning'
            );
          }
          else {
            drupal_set_message("Updated {$language_name} translations");
            //drupal_set_message('DEBUG: <pre>'.print_r($result,1).'</pre>');
          }
        }
        else {
          drupal_set_message("No translations to export for {$language_name}");
        }
      }
    }
    else {
      drupal_set_message(
        "Unable to update the translation source: {$result}",
        'warning'
      );
    }
  }
  else {
    drupal_set_message(
      'Failed to export translations: Transifex settings are not intiailized.',
      'error'
    );
  }
  drupal_goto('admin/boinc/translation');
}

/**
 *
 */
function boinctranslate_update_official_boinc_translations() {
  require_once(getcwd() . '/includes/locale.inc');
  $project_name = variable_get(
    'boinc_translate_transifex_standard_name', ''
  );
  $drupal_resource = variable_get(
    'boinc_translate_transifex_boinc_drupal_resource', ''
  );
  
  if ($project_name AND $drupal_resource) {
    // Create or update the translation source, if needed
    $source_exists = FALSE;
    $path = "project/{$project_name}/resources";
    $resources = boinctranslate_transifex_request($path);
    if ($resources AND is_array($resources)) {
      foreach ($resources as $resource) {
        if ($resource['slug'] == $drupal_resource) {
          $source_exists = TRUE;
          break;
        }
      }
      if (!$source_exists) {
        // Error
        $result = "ERROR: The {$drupal_resource} resource does not exist"
          . " in the {$project_name} project at Transifex";
      }
      else {
        // Update the source
        $path = "project/{$project_name}/resource/{$drupal_resource}/content";
        $post = array(
          'content' => boinctranslate_get_po('en', 'boinc')
        );
        $result = boinctranslate_transifex_request($path, $post);
      }
    }
    
    if ($result AND substr($result, 0, 6) != 'ERROR:') {
      $enabled_languages = locale_language_list();
      if ($source_exists) {
        drupal_set_message('Updated source translation strings at Transifex');
      }
      else {
        drupal_set_message('Established new translation resource at Transifex');
      }
      // Try to export translations for all enabled languages
      foreach ($enabled_languages as $langcode => $language_name) {
        if ($langcode == en) {
          continue;
        }
        $po_file = boinctranslate_get_po($langcode, 'boinc');
        if ($po_file) {
          $path = "project/{$project_name}/resource/{$drupal_resource}/translation/{$langcode}";
          $post = array(
            'content' => $po_file,
          );
          $result = boinctranslate_transifex_request($path, $post, TRUE, TRUE);
          if (!is_array($result)
          AND substr($result, 0, 6) == 'ERROR:') {
            drupal_set_message(
              "Unable to update {$language_name} official BOINC translations: {$result}",
              'warning'
            );
          }
          else {
            drupal_set_message("Updated {$language_name} official BOINC translations");
            //drupal_set_message('DEBUG: <pre>'.print_r($result,1).'</pre>');
          }
        }
        else {
          drupal_set_message("No official BOINC translations to export for {$language_name}");
        }
      }
    }
    else {
      drupal_set_message(
        "Unable to update the official BOINC translation source: {$result}",
        'warning'
      );
    }
  }
  else {
    drupal_set_message(
      'Failed to export official BOINC translations: Transifex settings are not intiailized.',
      'error'
    );
  }
  drupal_goto('admin/boinc/translation');
}

/**
 *
 */
function boinctranslate_transifex_request($path, $post = NULL, $json = TRUE, $use_put = FALSE) {
  // Transifex details
  $api_base_url = 'https://www.transifex.com/api/2';
  $username = variable_get('boinc_translate_transifex_user', '');
  $password = variable_get('boinc_translate_transifex_pass', '');
  
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, "{$api_base_url}/{$path}");
  $header = array(
    "Authorization: Basic " . base64_encode($username . ":" . $password)
  );
  if ($post AND $json) {
    $header[] = 'Content-Type: application/json';
    $post = json_encode($post);
  }
  curl_setopt($ch, CURLOPT_HTTPHEADER, $header);
  curl_setopt($ch, CURLOPT_HEADER, 1);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($ch, CURLOPT_TIMEOUT, 10);
  if ($post) curl_setopt($ch, CURLOPT_POSTFIELDS, $post);
  if ($use_put) curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
  $result = curl_exec($ch);
  
  list($response_header, $response_body) = explode("\r\n\r\n", $result, 2);
  
  if (strstr($response_header, '404 NOT FOUND')) {
    return '404 NOT FOUND';
  }
  elseif (strstr($response_header, '401 UNAUTHORIZED')) {
    return '401 UNAUTHORIZED';
  }
  elseif (strstr($response_header, '100 Continue')) {
    list($response_header, $response_body) = explode("\r\n\r\n", $response_body, 2);
    if ( strstr($response_header, '400 BAD REQUEST')) {
      return "ERROR: {$response_body}";
    }
  }
  elseif ($json) {
    // Process as JSON
    return json_decode($response_body, TRUE);
  }
  else {
    return (string) $response_body;
  }
}

/**
 *
 */
function boinctranslate_get_po($langcode, $type = 'standard') {
  $all_languages = language_list();
  $language = $all_languages[$langcode];
  $textgroups = array();
  $strings = array();
  
  switch ($type) {
  case 'standard':
    $textgroups = array(
      'default',
      'taxonomy',
      'views',
    );
    break;
  case 'boinc':
    $textgroups = array(
      'boinc',
    );
    break;
  case 'project':
    $textgroups = array(
      'blocks',
      'menu',
      'project',
    );
    break;
  default:
  }
  
  foreach ($textgroups as $textgroup) {
    $strings += _locale_export_get_strings($language, $textgroup);
  }
  if ($langcode != 'en') {
    // If not the source language, remove untranslated strings from the ouput
    foreach ($strings as $i => $string) {
      if (!$string['translation']) {
        unset($strings[$i]);
      }
    }
  }
  if ($strings) {
    return _locale_export_po_generate($language, $strings);
  }
  
  return NULL;
}

/**
 *
 */
function boinctranslate_refresh_translations() {
  require_once(getcwd() . '/includes/locale.inc');
  $errors = array();
  $languages = locale_language_list();
  $translation_resources = array();
  $operations = array();
  
  $boinc_name = variable_get(
    'boinc_translate_transifex_standard_name', ''
  );
  $boinc_resources = boinctranslate_parse_resources(
    variable_get('boinc_translate_transifex_standard_resources', array())
  );
  if ($boinc_name AND $boinc_resources) {
    $translation_resources[$boinc_name] = array(
      'resources' => $boinc_resources,
      'textgroups' => array(
        'boinc',
        'default',
        'taxonomy',
        'views',
      ),
    );
  }
  $project_name = variable_get(
    'boinc_translate_transifex_project_name', ''
  );
  $project_resources = boinctranslate_parse_resources(
    variable_get('boinc_translate_transifex_project_resources', array())
  );
  if ($project_name AND $project_resources) {
    $translation_resources[$project_name] = array(
      'resources' => $project_resources,
      'textgroups' => array(
        'blocks',
        'menu',
        'project',
      ),
    );
    // Be sure any strings from the override file are added to the boinc group
    $override_file = './' . drupal_get_path('module', 'boinctranslate') . '/includes/other-boinc-translation-strings.txt';
    $other_strings = file($override_file);
    if ($other_strings) {
      foreach ($other_strings as $string) {
        $string = trim($string);
        if ($string) {
          bts($string);
        }
      }
    }
  }
  
  foreach ($languages as $langcode => $language) {
    if ($langcode == 'en') {
      continue;
    }
    
    $import_stats = array(
      'new' => 0,
      'updated' => 0,
      'deleted' => 0,
      'skipped' => 0,
    );
  
    foreach ($translation_resources as $project => $translation) {
      foreach ($translation['resources'] as $resource) {
        
        // Add this language to the batch operations
        $operations[] = array(
          'boinctranslate_refresh_translations_op',
          array(
            $project, $resource, $langcode, $language, $translation['textgroups']
          ),
        );
      }
    }
    if ($batch = locale_batch_by_language($langcode)) {
      foreach ($batch['operations'] as $op) {
        $operations[] = array(
          'boinctranslate_refresh_translations_op',
          array(
            NULL, $op[1][0], $langcode, $language, array('default')
          ),
        );
      }
    }
  }
  
  $batch = array(
    'operations' => $operations,
    'finished' => 'boinctranslate_refresh_translations_finished',
    'title' => t('Importing translations'),
    'init_message' => t('Beginning translation import...'),
    'progress_message' => t('Applied @current out of @total translation updates.'),
    'error_message' => t('Translation import has encountered an error.'),
  );
  
  batch_set($batch);
  batch_process();
}


/**
 * Batch operation for importing translations
 */
function boinctranslate_refresh_translations_op($project, $resource, $langcode, $language, $textgroups, &$context) {
  require_once(getcwd() . '/includes/locale.inc');
  
  if ($project) {
    // Import the configured resources
    $success = FALSE;
    $message = '';
    $path = "project/{$project}/resource/{$resource}/translation/{$langcode}";
    $response = boinctranslate_transifex_request($path);
    
    if ($response == '404 NOT FOUND') {
      $message = "Project resource {$project}:{$resource} not found in {$language}.";
    }
    elseif ($response) {
      if (!empty($response['content'])) {
        $po_text = $response['content'];
        
        // Write the translation file to a temporary location
        $file = new stdClass();
        $file->filepath = file_save_data($po_text, NULL);
        $file->filename = basename($file->filepath);
        if (!$file->filepath) {
          $message = 'Unable to create temporary file in '
            . file_directory_temp() . " for {$language} translation "
            . "resource {$project}:{$resource}";
        }
        
        foreach ($textgroups as $textgroup) {
          // Import the translations from the file to each related textgroup
          if (!$results = _boinctranslate_locale_import_po($file, $langcode, LOCALE_IMPORT_OVERWRITE, $textgroup)) {
            $message = "The {$language} translation import of"
              . " {$project}:{$resource} failed.";
            $success = FALSE;
            break;
          }
          else {
            $success = TRUE;
          }
        }
      }
      else {
        $message = "Unable to read response for {$language} translation import"
          . " of {$project}:{$resource}.";
      }
    }
    else {
      $message = "Translation data not found in response for {$language}"
        . " translation import of {$project}:{$resource}.";
    }
  }
  else {
    // If project isn't specified, import as a local Drupal resource
    $project = 'drupal.local';
    $file = new stdClass();
    $file->filepath = $resource;
    $file->filename = basename($file->filepath);
    if (!$results = _boinctranslate_locale_import_po($file, $langcode, LOCALE_IMPORT_OVERWRITE, $textgroup)) {
      $message = "The {$language} translation import of"
        . " local file {$resource} failed.";
      $success = FALSE;
      break;
    }
    else {
      $success = TRUE;
    }
  }
  
  if ($success) {
    // Store some result for post-processing in the finished callback.
    $context['results']['success'][] = "{$langcode}:{$textgroup}";
    $message = "Imported translations for {$language} from {$project}:{$resource} ({$results['new']} added, {$results['updated']} refreshed, {$results['deleted']} removed)";
  }
  else {
    $context['results']['failure'][] = "{$langcode}:{$textgroup}";
    watchdog(
      'boinctranslate',
      $message,
      array(),
      WATCHDOG_WARNING
    );
  }
  
  // Update our progress information.
  $context['sandbox']['progress']++;
  $context['sandbox']['language'] = $langcode;
  $context['message'] = $message;

  // Update the progress for the batch engine
  if ($context['sandbox']['progress'] >= $context['sandbox']['max']) {
    $context['finished'] = 1;
  }
  else {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Batch 'finished' callback
 */
function boinctranslate_refresh_translations_finished($success, $results, $operations) {
  if ($success) {
    // Let's count our successes
    $count = count($results['success']);
    $message = "Successfully completed {$count} import operations";
    watchdog(
      'boinctranslate',
      'Successfully completed @count import operations.',
      array('@count' => $count),
      WATCHDOG_INFO
    ); 
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = 'An error occurred while processing ' . $error_operation[0] . ' with arguments :' . print_r($error_operation[0], TRUE);
    watchdog(
      'boinctranslate',
      $message,
      array(),
      WATCHDOG_WARNING
    );
  }
  drupal_set_message($message);
  drupal_goto('admin/boinc/translation');
}

/**
 *
 */
function _boinctranslate_locale_import_po($file, $langcode, $mode, $group = NULL) {
  // Try to allocate enough time to parse and import the data.
  if (function_exists('set_time_limit')) {
    @set_time_limit(240);
  }

  // Check if we have the language already in the database.
  if (!db_fetch_object(db_query("SELECT language FROM {languages} WHERE language = '%s'", $langcode))) {
    drupal_set_message(t('The language selected for import is not supported.'), 'error');
    return FALSE;
  }

  // Get strings from file (returns on failure after a partial import, or on success)
  $status = _boinctranslate_locale_import_read_po('db-store', $file, $mode, $langcode, $group);
  if ($status === FALSE) {
    // Error messages are set in _locale_import_read_po().
    return FALSE;
  }

  // Get status information on import process.
  list($headerdone, $additions, $updates, $deletes, $skips) = _boinctranslate_locale_import_one_string('db-report');
  
  if (!$headerdone) {
    drupal_set_message(t('The translation file %filename appears to have a missing or malformed header.', array('%filename' => $file->filename)), 'error');
  }
  
  // Clear cache and force refresh of JavaScript translations.
  _locale_invalidate_js($langcode);
  cache_clear_all('locale:', 'cache', TRUE);

  // Rebuild the menu, strings may have changed.
  menu_rebuild();
  
  return array(
    'new' => $additions,
    'updated' => $updates,
    'deleted' => $deletes,
    'skipped' => $skips,
  );
}

/**
 *
 */
function _boinctranslate_locale_import_read_po($op, $file, $mode = NULL, $lang = NULL, $group = 'default') {

  $fd = fopen($file->filepath, "rb"); // File will get closed by PHP on return
  if (!$fd) {
    _locale_import_message('The translation import failed, because the file %filename could not be read.', $file);
    return FALSE;
  }

  $context = "COMMENT"; // Parser context: COMMENT, MSGID, MSGID_PLURAL, MSGSTR and MSGSTR_ARR
  $current = array(); // Current entry being read
  $plural = 0; // Current plural form
  $lineno = 0; // Current line

  while (!feof($fd)) {
    $line = fgets($fd, 10 * 1024); // A line should not be this long
    if ($lineno == 0) {
      // The first line might come with a UTF-8 BOM, which should be removed.
      $line = str_replace("\xEF\xBB\xBF", '', $line);
    }
    $lineno++;
    $line = trim(strtr($line, array("\\\n" => "")));

    if (!strncmp("#", $line, 1)) { // A comment
      if ($context == "COMMENT") { // Already in comment context: add
        $current["#"][] = substr($line, 1);
      }
      elseif (($context == "MSGSTR") || ($context == "MSGSTR_ARR")) { // End current entry, start a new one
        _boinctranslate_locale_import_one_string($op, $current, $mode, $lang, $file, $group);
        $current = array();
        $current["#"][] = substr($line, 1);
        $context = "COMMENT";
      }
      else { // Parse error
        _locale_import_message('The translation file %filename contains an error: "msgstr" was expected but not found on line %line.', $file, $lineno);
        return FALSE;
      }
    }
    elseif (!strncmp("msgid_plural", $line, 12)) {
      if ($context != "MSGID") { // Must be plural form for current entry
        _locale_import_message('The translation file %filename contains an error: "msgid_plural" was expected but not found on line %line.', $file, $lineno);
        return FALSE;
      }
      $line = trim(substr($line, 12));
      $quoted = _locale_import_parse_quoted($line);
      if ($quoted === FALSE) {
        _locale_import_message('The translation file %filename contains a syntax error on line %line.', $file, $lineno);
        return FALSE;
      }
      $current["msgid"] = $current["msgid"] . "\0" . $quoted;
      $context = "MSGID_PLURAL";
    }
    elseif (!strncmp("msgid", $line, 5)) {
      if (($context == "MSGSTR") || ($context == "MSGSTR_ARR")) { // End current entry, start a new one
        _boinctranslate_locale_import_one_string($op, $current, $mode, $lang, $file, $group);
        $current = array();
      }
      elseif ($context == "MSGID") { // Already in this context? Parse error
        _locale_import_message('The translation file %filename contains an error: "msgid" is unexpected on line %line.', $file, $lineno);
        return FALSE;
      }
      $line = trim(substr($line, 5));
      $quoted = _locale_import_parse_quoted($line);
      if ($quoted === FALSE) {
        _locale_import_message('The translation file %filename contains a syntax error on line %line.', $file, $lineno);
        return FALSE;
      }
      $current["msgid"] = $quoted;
      $context = "MSGID";
    }
    elseif (!strncmp("msgstr[", $line, 7)) {
      if (($context != "MSGID") && ($context != "MSGID_PLURAL") && ($context != "MSGSTR_ARR")) { // Must come after msgid, msgid_plural, or msgstr[]
        _locale_import_message('The translation file %filename contains an error: "msgstr[]" is unexpected on line %line.', $file, $lineno);
        return FALSE;
      }
      if (strpos($line, "]") === FALSE) {
        _locale_import_message('The translation file %filename contains a syntax error on line %line.', $file, $lineno);
        return FALSE;
      }
      $frombracket = strstr($line, "[");
      $plural = substr($frombracket, 1, strpos($frombracket, "]") - 1);
      $line = trim(strstr($line, " "));
      $quoted = _locale_import_parse_quoted($line);
      if ($quoted === FALSE) {
        _locale_import_message('The translation file %filename contains a syntax error on line %line.', $file, $lineno);
        return FALSE;
      }
      $current["msgstr"][$plural] = $quoted;
      $context = "MSGSTR_ARR";
    }
    elseif (!strncmp("msgstr", $line, 6)) {
      if ($context != "MSGID") { // Should come just after a msgid block
        _locale_import_message('The translation file %filename contains an error: "msgstr" is unexpected on line %line.', $file, $lineno);
        return FALSE;
      }
      $line = trim(substr($line, 6));
      $quoted = _locale_import_parse_quoted($line);
      if ($quoted === FALSE) {
        _locale_import_message('The translation file %filename contains a syntax error on line %line.', $file, $lineno);
        return FALSE;
      }
      $current["msgstr"] = $quoted;
      $context = "MSGSTR";
    }
    elseif ($line != "") {
      $quoted = _locale_import_parse_quoted($line);
      if ($quoted === FALSE) {
        _locale_import_message('The translation file %filename contains a syntax error on line %line.', $file, $lineno);
        return FALSE;
      }
      if (($context == "MSGID") || ($context == "MSGID_PLURAL")) {
        $current["msgid"] .= $quoted;
      }
      elseif ($context == "MSGSTR") {
        $current["msgstr"] .= $quoted;
      }
      elseif ($context == "MSGSTR_ARR") {
        $current["msgstr"][$plural] .= $quoted;
      }
      else {
        _locale_import_message('The translation file %filename contains an error: there is an unexpected string on line %line.', $file, $lineno);
        return FALSE;
      }
    }
  }

  // End of PO file, flush last entry
  if (($context == "MSGSTR") || ($context == "MSGSTR_ARR")) {
    _boinctranslate_locale_import_one_string($op, $current, $mode, $lang, $file, $group);
  }
  elseif ($context != "COMMENT") {
    _locale_import_message('The translation file %filename ended unexpectedly at line %line.', $file, $lineno);
    return FALSE;
  }

}

/**
 *
 */
function _boinctranslate_locale_import_one_string($op, $value = NULL, $mode = NULL, $lang = NULL, $file = NULL, $group = 'default') {
  static $report = array(
    'additions' => 0,
    'updates' => 0,
    'deletes' => 0,
    'skips' => 0,
  );
  static $headerdone = FALSE;
  static $strings = array();

  switch ($op) {
    // Return stored strings
    case 'mem-report':
      return $strings;

      // Store string in memory (only supports single strings)
    case 'mem-store':
      $strings[$value['msgid']] = $value['msgstr'];
      return;

      // Called at end of import to inform the user
    case 'db-report':
      return array(
        $headerdone,
        $report['additions'],
        $report['updates'],
        $report['deletes'],
        $report['skips'],
      );

      // Store the string we got in the database.
    case 'db-store':
      // We got header information.
      if ($value['msgid'] == '') {
        $languages = language_list();
        if (($mode != LOCALE_IMPORT_KEEP) || empty($languages[$lang]->plurals)) {
          // Since we only need to parse the header if we ought to update the
          // plural formula, only run this if we don't need to keep existing
          // data untouched or if we don't have an existing plural formula.
          $header = _locale_import_parse_header($value['msgstr']);

          // Get and store the plural formula if available.
          if (isset($header["Plural-Forms"]) && $p = _locale_import_parse_plural_forms($header["Plural-Forms"], $file->filename)) {
            list($nplurals, $plural) = $p;
            db_query("UPDATE {languages} SET plurals = %d, formula = '%s' WHERE language = '%s'", $nplurals, $plural, $lang);
          }
        }
        $headerdone = TRUE;
      }

      else {
        // Some real string to import.
        $comments = _locale_import_shorten_comments(empty($value['#']) ? array() : $value['#']);

        if (strpos($value['msgid'], "\0")) {
          // This string has plural versions.
          $english = explode("\0", $value['msgid'], 2);
          $entries = array_keys($value['msgstr']);
          for ($i = 3; $i <= count($entries); $i++) {
            $english[] = $english[1];
          }
          $translation = array_map('_locale_import_append_plural', $value['msgstr'], $entries);
          $english = array_map('_locale_import_append_plural', $english, $entries);
          foreach ($translation as $key => $trans) {
            if ($key == 0) {
              $plid = 0;
            }
            $plid = _boinctranslate_locale_import_one_string_db($report, $lang, $english[$key], $trans, $group, $comments, $mode, $plid, $key);
          }
        }

        else {
          // A simple string to import.
          $english = $value['msgid'];
          $translation = $value['msgstr'];
          _boinctranslate_locale_import_one_string_db($report, $lang, $english, $translation, $group, $comments, $mode);
        }
      }
  } // end of db-store operation
}

/**
 * Modify the _locale_import_one_string_db() function so that it does not add
 * translation strings that do not exist on the site
 */
 function _boinctranslate_locale_import_one_string_db(&$report, $langcode, $source, $translation, $textgroup, $location, $mode, $plid = NULL, $plural = NULL) {
  $lid = db_result(db_query("SELECT lid FROM {locales_source} WHERE source = '%s' AND textgroup = '%s'", $source, $textgroup));

  if (!empty($translation)) {
    // Skip this string unless it passes a check for dangerous code.
    // Text groups other than default still can contain HTML tags
    // (i.e. translatable blocks).
    if ($textgroup == "default" && !locale_string_is_safe($translation)) {
      $report['skips']++;
      $lid = 0;
    }
    elseif ($lid) {
      // We have this source string saved already.
      // Don't update location, that just makes Drupal add the same strings
      // over and over
      //db_query("UPDATE {locales_source} SET location = '%s' WHERE lid = %d", $location, $lid);
      $exists = (bool) db_result(db_query("SELECT lid FROM {locales_target} WHERE lid = %d AND language = '%s'", $lid, $langcode));
      if (!$exists) {
        // No translation in this language.
        db_query("INSERT INTO {locales_target} (lid, language, translation, plid, plural) VALUES (%d, '%s', '%s', %d, %d)", $lid, $langcode, $translation, $plid, $plural);
        $report['additions']++;
      }
      else if ($mode == LOCALE_IMPORT_OVERWRITE) {
        // Translation exists, only overwrite if instructed.
        db_query("UPDATE {locales_target} SET translation = '%s', plid = %d, plural = %d WHERE language = '%s' AND lid = %d", $translation, $plid, $plural, $langcode, $lid);
        $report['updates']++;
      }
    }
    else {
      // No such source string in the database yet.
      // Do not insert the source string if it does not belong on the site!
      /*
      db_query("INSERT INTO {locales_source} (location, source, textgroup) VALUES ('%s', '%s', '%s')", $location, $source, $textgroup);
      $lid = db_result(db_query("SELECT lid FROM {locales_source} WHERE source = '%s' AND textgroup = '%s'", $source, $textgroup));
      db_query("INSERT INTO {locales_target} (lid, language, translation, plid, plural) VALUES (%d, '%s', '%s', %d, %d)", $lid, $langcode, $translation, $plid, $plural);
      $report['additions']++;
      */
    }
  }
  elseif ($mode == LOCALE_IMPORT_OVERWRITE AND $lid) {
    $exists = (bool) db_result(db_query("SELECT lid FROM {locales_target} WHERE lid = %d AND language = '%s'", $lid, $langcode));
    if ($exists) {
      // Empty translation, remove existing if instructed.
      db_query("DELETE FROM {locales_target} WHERE language = '%s' AND lid = %d AND plid = %d AND plural = %d", $langcode, $lid, $plid, $plural);
      $report['deletes']++;
    }
  }
  else {
    $report['skips']++;
  }

  return $lid;
}



/**
 * Parse valid resources out of configuration
 */
function boinctranslate_parse_resources($resource_text) {
  $resources = array();
  $resource_array = explode(
    "\n", $resource_text
  );
  foreach ($resource_array as $resource) {
    $resource = trim($resource);
    if ($resource AND $resource[0] != '#') {
      $resources[] = $resource;
    }
  }
  return $resources;
}
